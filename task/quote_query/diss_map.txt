
map:     file format elf64-x86-64


Disassembly of section .init:

0000000000400678 <_init>:
  400678:	48 83 ec 08          	sub    $0x8,%rsp
  40067c:	48 8b 05 d5 11 20 00 	mov    0x2011d5(%rip),%rax        # 601858 <_DYNAMIC+0x1d0>
  400683:	48 85 c0             	test   %rax,%rax
  400686:	74 05                	je     40068d <_init+0x15>
  400688:	e8 b3 00 00 00       	callq  400740 <__gmon_start__@plt>
  40068d:	48 83 c4 08          	add    $0x8,%rsp
  400691:	c3                   	retq   

Disassembly of section .plt:

00000000004006a0 <free@plt-0x10>:
  4006a0:	ff 35 c2 11 20 00    	pushq  0x2011c2(%rip)        # 601868 <_GLOBAL_OFFSET_TABLE_+0x8>
  4006a6:	ff 25 c4 11 20 00    	jmpq   *0x2011c4(%rip)        # 601870 <_GLOBAL_OFFSET_TABLE_+0x10>
  4006ac:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004006b0 <free@plt>:
  4006b0:	ff 25 c2 11 20 00    	jmpq   *0x2011c2(%rip)        # 601878 <_GLOBAL_OFFSET_TABLE_+0x18>
  4006b6:	68 00 00 00 00       	pushq  $0x0
  4006bb:	e9 e0 ff ff ff       	jmpq   4006a0 <_init+0x28>

00000000004006c0 <__errno_location@plt>:
  4006c0:	ff 25 ba 11 20 00    	jmpq   *0x2011ba(%rip)        # 601880 <_GLOBAL_OFFSET_TABLE_+0x20>
  4006c6:	68 01 00 00 00       	pushq  $0x1
  4006cb:	e9 d0 ff ff ff       	jmpq   4006a0 <_init+0x28>

00000000004006d0 <strcpy@plt>:
  4006d0:	ff 25 b2 11 20 00    	jmpq   *0x2011b2(%rip)        # 601888 <_GLOBAL_OFFSET_TABLE_+0x28>
  4006d6:	68 02 00 00 00       	pushq  $0x2
  4006db:	e9 c0 ff ff ff       	jmpq   4006a0 <_init+0x28>

00000000004006e0 <puts@plt>:
  4006e0:	ff 25 aa 11 20 00    	jmpq   *0x2011aa(%rip)        # 601890 <_GLOBAL_OFFSET_TABLE_+0x30>
  4006e6:	68 03 00 00 00       	pushq  $0x3
  4006eb:	e9 b0 ff ff ff       	jmpq   4006a0 <_init+0x28>

00000000004006f0 <fclose@plt>:
  4006f0:	ff 25 a2 11 20 00    	jmpq   *0x2011a2(%rip)        # 601898 <_GLOBAL_OFFSET_TABLE_+0x38>
  4006f6:	68 04 00 00 00       	pushq  $0x4
  4006fb:	e9 a0 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400700 <printf@plt>:
  400700:	ff 25 9a 11 20 00    	jmpq   *0x20119a(%rip)        # 6018a0 <_GLOBAL_OFFSET_TABLE_+0x40>
  400706:	68 05 00 00 00       	pushq  $0x5
  40070b:	e9 90 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400710 <memset@plt>:
  400710:	ff 25 92 11 20 00    	jmpq   *0x201192(%rip)        # 6018a8 <_GLOBAL_OFFSET_TABLE_+0x48>
  400716:	68 06 00 00 00       	pushq  $0x6
  40071b:	e9 80 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400720 <__libc_start_main@plt>:
  400720:	ff 25 8a 11 20 00    	jmpq   *0x20118a(%rip)        # 6018b0 <_GLOBAL_OFFSET_TABLE_+0x50>
  400726:	68 07 00 00 00       	pushq  $0x7
  40072b:	e9 70 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400730 <fgets@plt>:
  400730:	ff 25 82 11 20 00    	jmpq   *0x201182(%rip)        # 6018b8 <_GLOBAL_OFFSET_TABLE_+0x58>
  400736:	68 08 00 00 00       	pushq  $0x8
  40073b:	e9 60 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400740 <__gmon_start__@plt>:
  400740:	ff 25 7a 11 20 00    	jmpq   *0x20117a(%rip)        # 6018c0 <_GLOBAL_OFFSET_TABLE_+0x60>
  400746:	68 09 00 00 00       	pushq  $0x9
  40074b:	e9 50 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400750 <memcpy@plt>:
  400750:	ff 25 72 11 20 00    	jmpq   *0x201172(%rip)        # 6018c8 <_GLOBAL_OFFSET_TABLE_+0x68>
  400756:	68 0a 00 00 00       	pushq  $0xa
  40075b:	e9 40 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400760 <malloc@plt>:
  400760:	ff 25 6a 11 20 00    	jmpq   *0x20116a(%rip)        # 6018d0 <_GLOBAL_OFFSET_TABLE_+0x70>
  400766:	68 0b 00 00 00       	pushq  $0xb
  40076b:	e9 30 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400770 <fopen@plt>:
  400770:	ff 25 62 11 20 00    	jmpq   *0x201162(%rip)        # 6018d8 <_GLOBAL_OFFSET_TABLE_+0x78>
  400776:	68 0c 00 00 00       	pushq  $0xc
  40077b:	e9 20 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400780 <atoi@plt>:
  400780:	ff 25 5a 11 20 00    	jmpq   *0x20115a(%rip)        # 6018e0 <_GLOBAL_OFFSET_TABLE_+0x80>
  400786:	68 0d 00 00 00       	pushq  $0xd
  40078b:	e9 10 ff ff ff       	jmpq   4006a0 <_init+0x28>

0000000000400790 <strerror@plt>:
  400790:	ff 25 52 11 20 00    	jmpq   *0x201152(%rip)        # 6018e8 <_GLOBAL_OFFSET_TABLE_+0x88>
  400796:	68 0e 00 00 00       	pushq  $0xe
  40079b:	e9 00 ff ff ff       	jmpq   4006a0 <_init+0x28>

Disassembly of section .text:

00000000004007a0 <_start>:
  4007a0:	31 ed                	xor    %ebp,%ebp
  4007a2:	49 89 d1             	mov    %rdx,%r9
  4007a5:	5e                   	pop    %rsi
  4007a6:	48 89 e2             	mov    %rsp,%rdx
  4007a9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4007ad:	50                   	push   %rax
  4007ae:	54                   	push   %rsp
  4007af:	49 c7 c0 40 12 40 00 	mov    $0x401240,%r8
  4007b6:	48 c7 c1 d0 11 40 00 	mov    $0x4011d0,%rcx
  4007bd:	48 c7 c7 ec 10 40 00 	mov    $0x4010ec,%rdi
  4007c4:	e8 57 ff ff ff       	callq  400720 <__libc_start_main@plt>
  4007c9:	f4                   	hlt    
  4007ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004007d0 <deregister_tm_clones>:
  4007d0:	b8 07 19 60 00       	mov    $0x601907,%eax
  4007d5:	55                   	push   %rbp
  4007d6:	48 2d 00 19 60 00    	sub    $0x601900,%rax
  4007dc:	48 83 f8 0e          	cmp    $0xe,%rax
  4007e0:	48 89 e5             	mov    %rsp,%rbp
  4007e3:	76 1b                	jbe    400800 <deregister_tm_clones+0x30>
  4007e5:	b8 00 00 00 00       	mov    $0x0,%eax
  4007ea:	48 85 c0             	test   %rax,%rax
  4007ed:	74 11                	je     400800 <deregister_tm_clones+0x30>
  4007ef:	5d                   	pop    %rbp
  4007f0:	bf 00 19 60 00       	mov    $0x601900,%edi
  4007f5:	ff e0                	jmpq   *%rax
  4007f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4007fe:	00 00 
  400800:	5d                   	pop    %rbp
  400801:	c3                   	retq   
  400802:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  400809:	1f 84 00 00 00 00 00 

0000000000400810 <register_tm_clones>:
  400810:	be 00 19 60 00       	mov    $0x601900,%esi
  400815:	55                   	push   %rbp
  400816:	48 81 ee 00 19 60 00 	sub    $0x601900,%rsi
  40081d:	48 c1 fe 03          	sar    $0x3,%rsi
  400821:	48 89 e5             	mov    %rsp,%rbp
  400824:	48 89 f0             	mov    %rsi,%rax
  400827:	48 c1 e8 3f          	shr    $0x3f,%rax
  40082b:	48 01 c6             	add    %rax,%rsi
  40082e:	48 d1 fe             	sar    %rsi
  400831:	74 15                	je     400848 <register_tm_clones+0x38>
  400833:	b8 00 00 00 00       	mov    $0x0,%eax
  400838:	48 85 c0             	test   %rax,%rax
  40083b:	74 0b                	je     400848 <register_tm_clones+0x38>
  40083d:	5d                   	pop    %rbp
  40083e:	bf 00 19 60 00       	mov    $0x601900,%edi
  400843:	ff e0                	jmpq   *%rax
  400845:	0f 1f 00             	nopl   (%rax)
  400848:	5d                   	pop    %rbp
  400849:	c3                   	retq   
  40084a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400850 <__do_global_dtors_aux>:
  400850:	80 3d a9 10 20 00 00 	cmpb   $0x0,0x2010a9(%rip)        # 601900 <__TMC_END__>
  400857:	75 11                	jne    40086a <__do_global_dtors_aux+0x1a>
  400859:	55                   	push   %rbp
  40085a:	48 89 e5             	mov    %rsp,%rbp
  40085d:	e8 6e ff ff ff       	callq  4007d0 <deregister_tm_clones>
  400862:	5d                   	pop    %rbp
  400863:	c6 05 96 10 20 00 01 	movb   $0x1,0x201096(%rip)        # 601900 <__TMC_END__>
  40086a:	f3 c3                	repz retq 
  40086c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400870 <frame_dummy>:
  400870:	bf 80 16 60 00       	mov    $0x601680,%edi
  400875:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  400879:	75 05                	jne    400880 <frame_dummy+0x10>
  40087b:	eb 93                	jmp    400810 <register_tm_clones>
  40087d:	0f 1f 00             	nopl   (%rax)
  400880:	b8 00 00 00 00       	mov    $0x0,%eax
  400885:	48 85 c0             	test   %rax,%rax
  400888:	74 f1                	je     40087b <frame_dummy+0xb>
  40088a:	55                   	push   %rbp
  40088b:	48 89 e5             	mov    %rsp,%rbp
  40088e:	ff d0                	callq  *%rax
  400890:	5d                   	pop    %rbp
  400891:	e9 7a ff ff ff       	jmpq   400810 <register_tm_clones>

0000000000400896 <calculate_item_key>:
uint32_t calculate_year_key( uint32_t date )	;
struct quote_map* qsvr_init(const char *path)	;
void map_key(struct quote_map *map_val , uint32_t len );

uint32_t calculate_item_key(char *array )
{
  400896:	55                   	push   %rbp
  400897:	48 89 e5             	mov    %rsp,%rbp
  40089a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
     uint32_t seed = 131; // 31 131 1313 13131 131313 etc..
  40089e:	c7 45 f8 83 00 00 00 	movl   $0x83,-0x8(%rbp)
     uint32_t hash = 0 ;
  4008a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
      
     while (*array)
  4008ac:	eb 20                	jmp    4008ce <calculate_item_key+0x38>
     {
          hash = hash * seed + (*array++);
  4008ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4008b1:	0f af 45 f8          	imul   -0x8(%rbp),%eax
  4008b5:	89 c1                	mov    %eax,%ecx
  4008b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4008bb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4008bf:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4008c3:	0f b6 00             	movzbl (%rax),%eax
  4008c6:	0f be c0             	movsbl %al,%eax
  4008c9:	01 c8                	add    %ecx,%eax
  4008cb:	89 45 fc             	mov    %eax,-0x4(%rbp)
uint32_t calculate_item_key(char *array )
{
     uint32_t seed = 131; // 31 131 1313 13131 131313 etc..
     uint32_t hash = 0 ;
      
     while (*array)
  4008ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4008d2:	0f b6 00             	movzbl (%rax),%eax
  4008d5:	84 c0                	test   %al,%al
  4008d7:	75 d5                	jne    4008ae <calculate_item_key+0x18>
     {
          hash = hash * seed + (*array++);
     }
      
     return  (hash & 0x1ff); 
  4008d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4008dc:	25 ff 01 00 00       	and    $0x1ff,%eax
}
  4008e1:	5d                   	pop    %rbp
  4008e2:	c3                   	retq   

00000000004008e3 <Is_Leap_year>:

uint32_t  Is_Leap_year(uint32_t year )
{
  4008e3:	55                   	push   %rbp
  4008e4:	48 89 e5             	mov    %rsp,%rbp
  4008e7:	89 7d ec             	mov    %edi,-0x14(%rbp)
     uint32_t Leap = 0 ;
  4008ea:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
     if( ((year%4 == 0)&&(year%100 != 0)) ||(year%400==0))
  4008f1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4008f4:	83 e0 03             	and    $0x3,%eax
  4008f7:	85 c0                	test   %eax,%eax
  4008f9:	75 1c                	jne    400917 <Is_Leap_year+0x34>
  4008fb:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  4008fe:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  400903:	89 c8                	mov    %ecx,%eax
  400905:	f7 e2                	mul    %edx
  400907:	89 d0                	mov    %edx,%eax
  400909:	c1 e8 05             	shr    $0x5,%eax
  40090c:	6b c0 64             	imul   $0x64,%eax,%eax
  40090f:	29 c1                	sub    %eax,%ecx
  400911:	89 c8                	mov    %ecx,%eax
  400913:	85 c0                	test   %eax,%eax
  400915:	75 1f                	jne    400936 <Is_Leap_year+0x53>
  400917:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  40091a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  40091f:	89 c8                	mov    %ecx,%eax
  400921:	f7 e2                	mul    %edx
  400923:	89 d0                	mov    %edx,%eax
  400925:	c1 e8 07             	shr    $0x7,%eax
  400928:	69 c0 90 01 00 00    	imul   $0x190,%eax,%eax
  40092e:	29 c1                	sub    %eax,%ecx
  400930:	89 c8                	mov    %ecx,%eax
  400932:	85 c0                	test   %eax,%eax
  400934:	75 07                	jne    40093d <Is_Leap_year+0x5a>
          Leap = 1 ;
  400936:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

return Leap ;
  40093d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  400940:	5d                   	pop    %rbp
  400941:	c3                   	retq   

0000000000400942 <calculate_year_key>:

uint32_t calculate_year_key( uint32_t date )
{
  400942:	55                   	push   %rbp
  400943:	48 89 e5             	mov    %rsp,%rbp
  400946:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  40094d:	89 bd 0c ff ff ff    	mov    %edi,-0xf4(%rbp)
	uint32_t  Leap_array[] = {0 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,3 ,3 ,3 ,3 ,4 ,4 ,4 ,4 ,5   ,5 ,5 ,5 ,6 ,6 ,6 ,6 ,7 ,7 ,7 ,7 ,8 ,8 ,8 ,8 ,9 ,9 ,9 ,9 ,10 ,10 ,10 ,10 };
  400953:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  40095a:	be c0 12 40 00       	mov    $0x4012c0,%esi
  40095f:	ba 14 00 00 00       	mov    $0x14,%edx
  400964:	48 89 c7             	mov    %rax,%rdi
  400967:	48 89 d1             	mov    %rdx,%rcx
  40096a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
  
    uint32_t  min_month_flag[] ={0,0,0,1,1,2,2,2,3,3,4,4}; //NOT ZERO mean stand   the total of min month from January,except February
  40096d:	c7 85 10 ff ff ff 00 	movl   $0x0,-0xf0(%rbp)
  400974:	00 00 00 
  400977:	c7 85 14 ff ff ff 00 	movl   $0x0,-0xec(%rbp)
  40097e:	00 00 00 
  400981:	c7 85 18 ff ff ff 00 	movl   $0x0,-0xe8(%rbp)
  400988:	00 00 00 
  40098b:	c7 85 1c ff ff ff 01 	movl   $0x1,-0xe4(%rbp)
  400992:	00 00 00 
  400995:	c7 85 20 ff ff ff 01 	movl   $0x1,-0xe0(%rbp)
  40099c:	00 00 00 
  40099f:	c7 85 24 ff ff ff 02 	movl   $0x2,-0xdc(%rbp)
  4009a6:	00 00 00 
  4009a9:	c7 85 28 ff ff ff 02 	movl   $0x2,-0xd8(%rbp)
  4009b0:	00 00 00 
  4009b3:	c7 85 2c ff ff ff 02 	movl   $0x2,-0xd4(%rbp)
  4009ba:	00 00 00 
  4009bd:	c7 85 30 ff ff ff 03 	movl   $0x3,-0xd0(%rbp)
  4009c4:	00 00 00 
  4009c7:	c7 85 34 ff ff ff 03 	movl   $0x3,-0xcc(%rbp)
  4009ce:	00 00 00 
  4009d1:	c7 85 38 ff ff ff 04 	movl   $0x4,-0xc8(%rbp)
  4009d8:	00 00 00 
  4009db:	c7 85 3c ff ff ff 04 	movl   $0x4,-0xc4(%rbp)
  4009e2:	00 00 00 
    uint32_t  day ,month ,year ,Leap = 0 ,all_day ,year_day ;
  4009e5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  
    day     =   date %100;
  4009ec:	8b 8d 0c ff ff ff    	mov    -0xf4(%rbp),%ecx
  4009f2:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  4009f7:	89 c8                	mov    %ecx,%eax
  4009f9:	f7 e2                	mul    %edx
  4009fb:	89 d0                	mov    %edx,%eax
  4009fd:	c1 e8 05             	shr    $0x5,%eax
  400a00:	6b c0 64             	imul   $0x64,%eax,%eax
  400a03:	29 c1                	sub    %eax,%ecx
  400a05:	89 c8                	mov    %ecx,%eax
  400a07:	89 45 f4             	mov    %eax,-0xc(%rbp)
    month   =   (date%10000)/100;
  400a0a:	8b 8d 0c ff ff ff    	mov    -0xf4(%rbp),%ecx
  400a10:	ba 59 17 b7 d1       	mov    $0xd1b71759,%edx
  400a15:	89 c8                	mov    %ecx,%eax
  400a17:	f7 e2                	mul    %edx
  400a19:	89 d0                	mov    %edx,%eax
  400a1b:	c1 e8 0d             	shr    $0xd,%eax
  400a1e:	69 c0 10 27 00 00    	imul   $0x2710,%eax,%eax
  400a24:	29 c1                	sub    %eax,%ecx
  400a26:	89 c8                	mov    %ecx,%eax
  400a28:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  400a2d:	f7 e2                	mul    %edx
  400a2f:	89 d0                	mov    %edx,%eax
  400a31:	c1 e8 05             	shr    $0x5,%eax
  400a34:	89 45 f0             	mov    %eax,-0x10(%rbp)
    year    =   (date/10000);
  400a37:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  400a3d:	ba 59 17 b7 d1       	mov    $0xd1b71759,%edx
  400a42:	f7 e2                	mul    %edx
  400a44:	89 d0                	mov    %edx,%eax
  400a46:	c1 e8 0d             	shr    $0xd,%eax
  400a49:	89 45 ec             	mov    %eax,-0x14(%rbp)
    Leap =  Is_Leap_year(year);
  400a4c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400a4f:	89 c7                	mov    %eax,%edi
  400a51:	e8 8d fe ff ff       	callq  4008e3 <Is_Leap_year>
  400a56:	89 45 f8             	mov    %eax,-0x8(%rbp)
  
    if ((month -1) >= 2)
  400a59:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400a5c:	83 e8 01             	sub    $0x1,%eax
  400a5f:	83 f8 01             	cmp    $0x1,%eax
  400a62:	76 58                	jbe    400abc <calculate_year_key+0x17a>
    {
    	year_day  = (month-2)*31 -min_month_flag[month-2] + day  + 28 + Leap ;       
  400a64:	8b 55 f0             	mov    -0x10(%rbp),%edx
  400a67:	89 d0                	mov    %edx,%eax
  400a69:	c1 e0 05             	shl    $0x5,%eax
  400a6c:	29 d0                	sub    %edx,%eax
  400a6e:	89 c2                	mov    %eax,%edx
  400a70:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400a73:	83 e8 02             	sub    $0x2,%eax
  400a76:	89 c0                	mov    %eax,%eax
  400a78:	8b 84 85 10 ff ff ff 	mov    -0xf0(%rbp,%rax,4),%eax
  400a7f:	29 c2                	sub    %eax,%edx
  400a81:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400a84:	01 c2                	add    %eax,%edx
  400a86:	8b 45 f8             	mov    -0x8(%rbp),%eax
  400a89:	01 d0                	add    %edx,%eax
  400a8b:	83 e8 22             	sub    $0x22,%eax
  400a8e:	89 45 e8             	mov    %eax,-0x18(%rbp)
        all_day   = year_day + (year - 2012)*365 +Leap_array[year-2012] - Start_day  ;
  400a91:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400a94:	69 d0 6d 01 00 00    	imul   $0x16d,%eax,%edx
  400a9a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400a9d:	01 c2                	add    %eax,%edx
  400a9f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400aa2:	2d dc 07 00 00       	sub    $0x7dc,%eax
  400aa7:	89 c0                	mov    %eax,%eax
  400aa9:	8b 84 85 40 ff ff ff 	mov    -0xc0(%rbp,%rax,4),%eax
  400ab0:	01 d0                	add    %edx,%eax
  400ab2:	2d 45 35 0b 00       	sub    $0xb3545,%eax
  400ab7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  400aba:	eb 63                	jmp    400b1f <calculate_year_key+0x1dd>
    }
    else if (month == 2)
  400abc:	83 7d f0 02          	cmpl   $0x2,-0x10(%rbp)
  400ac0:	75 34                	jne    400af6 <calculate_year_key+0x1b4>
    {
       year_day = 31 + day ;
  400ac2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400ac5:	83 c0 1f             	add    $0x1f,%eax
  400ac8:	89 45 e8             	mov    %eax,-0x18(%rbp)
       all_day  = year_day + (year -2012)*365 +Leap_array[year-2012] - Start_day;
  400acb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400ace:	69 d0 6d 01 00 00    	imul   $0x16d,%eax,%edx
  400ad4:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400ad7:	01 c2                	add    %eax,%edx
  400ad9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400adc:	2d dc 07 00 00       	sub    $0x7dc,%eax
  400ae1:	89 c0                	mov    %eax,%eax
  400ae3:	8b 84 85 40 ff ff ff 	mov    -0xc0(%rbp,%rax,4),%eax
  400aea:	01 d0                	add    %edx,%eax
  400aec:	2d 45 35 0b 00       	sub    $0xb3545,%eax
  400af1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  400af4:	eb 29                	jmp    400b1f <calculate_year_key+0x1dd>
    }
    else
    {
       all_day = day + (year - 2012)*365 +Leap_array[year-2012] - Start_day;
  400af6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400af9:	69 d0 6d 01 00 00    	imul   $0x16d,%eax,%edx
  400aff:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400b02:	01 c2                	add    %eax,%edx
  400b04:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400b07:	2d dc 07 00 00       	sub    $0x7dc,%eax
  400b0c:	89 c0                	mov    %eax,%eax
  400b0e:	8b 84 85 40 ff ff ff 	mov    -0xc0(%rbp,%rax,4),%eax
  400b15:	01 d0                	add    %edx,%eax
  400b17:	2d 45 35 0b 00       	sub    $0xb3545,%eax
  400b1c:	89 45 fc             	mov    %eax,-0x4(%rbp)
    }
return all_day;
  400b1f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  400b22:	c9                   	leaveq 
  400b23:	c3                   	retq   

0000000000400b24 <map_key>:
void map_key(struct quote_map *map_val , uint32_t len )
{   
  400b24:	55                   	push   %rbp
  400b25:	48 89 e5             	mov    %rsp,%rbp
  400b28:	48 83 ec 30          	sub    $0x30,%rsp
  400b2c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  400b30:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	 uint32_t year=0 ,month=0 ,day=0,year_key = 0,item_key = 0 ,rank_key = 0 ;
  400b33:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  400b3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  400b41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  400b48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400b4f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  400b56:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
     for(int i =0 ;i < len ;i++)
  400b5d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400b64:	e9 b8 00 00 00       	jmpq   400c21 <map_key+0xfd>
     {
         year_key =  calculate_year_key(map_val->origin_array[i].date );
  400b69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b6d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400b71:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400b74:	48 98                	cltq   
  400b76:	48 69 c0 b8 00 00 00 	imul   $0xb8,%rax,%rax
  400b7d:	48 01 d0             	add    %rdx,%rax
  400b80:	8b 00                	mov    (%rax),%eax
  400b82:	89 c7                	mov    %eax,%edi
  400b84:	e8 b9 fd ff ff       	callq  400942 <calculate_year_key>
  400b89:	89 45 ec             	mov    %eax,-0x14(%rbp)
         item_key  = calculate_item_key(map_val->origin_array[i].item );
  400b8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b90:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400b94:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400b97:	48 98                	cltq   
  400b99:	48 69 c0 b8 00 00 00 	imul   $0xb8,%rax,%rax
  400ba0:	48 01 d0             	add    %rdx,%rax
  400ba3:	48 83 c0 04          	add    $0x4,%rax
  400ba7:	48 89 c7             	mov    %rax,%rdi
  400baa:	e8 e7 fc ff ff       	callq  400896 <calculate_item_key>
  400baf:	89 45 e8             	mov    %eax,-0x18(%rbp)
         item_key    = map_val->hash[item_key] + map_val->origin_array[i].rank;
  400bb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400bb6:	48 8b 40 08          	mov    0x8(%rax),%rax
  400bba:	8b 55 e8             	mov    -0x18(%rbp),%edx
  400bbd:	48 c1 e2 02          	shl    $0x2,%rdx
  400bc1:	48 01 d0             	add    %rdx,%rax
  400bc4:	8b 10                	mov    (%rax),%edx
  400bc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400bca:	48 8b 48 10          	mov    0x10(%rax),%rcx
  400bce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400bd1:	48 98                	cltq   
  400bd3:	48 69 c0 b8 00 00 00 	imul   $0xb8,%rax,%rax
  400bda:	48 01 c8             	add    %rcx,%rax
  400bdd:	8b 40 14             	mov    0x14(%rax),%eax
  400be0:	01 d0                	add    %edx,%eax
  400be2:	89 45 e8             	mov    %eax,-0x18(%rbp)
          
       	map_val->index_array[year_key][item_key]=(int *) (map_val->origin_array + i);
  400be5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400be9:	48 8b 00             	mov    (%rax),%rax
  400bec:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400bef:	48 c1 e2 03          	shl    $0x3,%rdx
  400bf3:	48 01 d0             	add    %rdx,%rax
  400bf6:	48 8b 00             	mov    (%rax),%rax
  400bf9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  400bfc:	48 c1 e2 03          	shl    $0x3,%rdx
  400c00:	48 01 c2             	add    %rax,%rdx
  400c03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400c07:	48 8b 48 10          	mov    0x10(%rax),%rcx
  400c0b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400c0e:	48 98                	cltq   
  400c10:	48 69 c0 b8 00 00 00 	imul   $0xb8,%rax,%rax
  400c17:	48 01 c8             	add    %rcx,%rax
  400c1a:	48 89 02             	mov    %rax,(%rdx)
return all_day;
}
void map_key(struct quote_map *map_val , uint32_t len )
{   
	 uint32_t year=0 ,month=0 ,day=0,year_key = 0,item_key = 0 ,rank_key = 0 ;
     for(int i =0 ;i < len ;i++)
  400c1d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400c21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400c24:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
  400c27:	0f 82 3c ff ff ff    	jb     400b69 <map_key+0x45>
         item_key    = map_val->hash[item_key] + map_val->origin_array[i].rank;
          
       	map_val->index_array[year_key][item_key]=(int *) (map_val->origin_array + i);
     }
   
}
  400c2d:	c9                   	leaveq 
  400c2e:	c3                   	retq   

0000000000400c2f <qsvr_init>:


struct quote_map*
qsvr_init(const char *path)
{
  400c2f:	55                   	push   %rbp
  400c30:	48 89 e5             	mov    %rsp,%rbp
  400c33:	53                   	push   %rbx
  400c34:	48 81 ec 28 09 00 00 	sub    $0x928,%rsp
  400c3b:	48 89 bd d8 f6 ff ff 	mov    %rdi,-0x928(%rbp)
	uint32_t hash_key[512] = {0};
  400c42:	48 8d 95 a0 f7 ff ff 	lea    -0x860(%rbp),%rdx
  400c49:	b8 00 00 00 00       	mov    $0x0,%eax
  400c4e:	b9 00 01 00 00       	mov    $0x100,%ecx
  400c53:	48 89 d7             	mov    %rdx,%rdi
  400c56:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	struct quote_map* init_val;
	init_val = (struct quote_map *)malloc(sizeof(struct quote_map));
  400c59:	bf d0 00 00 00       	mov    $0xd0,%edi
  400c5e:	e8 fd fa ff ff       	callq  400760 <malloc@plt>
  400c63:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	memset(init_val,0,sizeof(struct quote_map));
  400c67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  400c6b:	ba d0 00 00 00       	mov    $0xd0,%edx
  400c70:	be 00 00 00 00       	mov    $0x0,%esi
  400c75:	48 89 c7             	mov    %rax,%rdi
  400c78:	e8 93 fa ff ff       	callq  400710 <memset@plt>
	
	int index = 0 ; 
  400c7d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    unsigned long start, end;
    uint32_t input_data_len = sizeof(struct qsvr )*History_len;
  400c84:	c7 45 c4 20 d5 a9 04 	movl   $0x4a9d520,-0x3c(%rbp)
    uint32_t malloc_sec_hash_len = Second_hash_index * sizeof(uint32_t *);
  400c8b:	c7 45 c0 b0 02 00 00 	movl   $0x2b0,-0x40(%rbp)
	
	struct qsvr * origin_array ;
	origin_array = (struct qsvr *) malloc(input_data_len); 
  400c92:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  400c95:	48 89 c7             	mov    %rax,%rdi
  400c98:	e8 c3 fa ff ff       	callq  400760 <malloc@plt>
  400c9d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	
	uint32_t ***index_array ;
	index_array     = (uint32_t ***)malloc(sizeof(uint32_t *));
  400ca1:	bf 08 00 00 00       	mov    $0x8,%edi
  400ca6:	e8 b5 fa ff ff       	callq  400760 <malloc@plt>
  400cab:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    for(int i = 0 ; i < Days  ; i++)
  400caf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  400cb6:	eb 27                	jmp    400cdf <qsvr_init+0xb0>
          index_array[i]  = (uint32_t **)malloc(malloc_sec_hash_len);
  400cb8:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400cbb:	48 98                	cltq   
  400cbd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400cc4:	00 
  400cc5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  400cc9:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  400ccd:	8b 45 c0             	mov    -0x40(%rbp),%eax
  400cd0:	48 89 c7             	mov    %rax,%rdi
  400cd3:	e8 88 fa ff ff       	callq  400760 <malloc@plt>
  400cd8:	48 89 03             	mov    %rax,(%rbx)
	struct qsvr * origin_array ;
	origin_array = (struct qsvr *) malloc(input_data_len); 
	
	uint32_t ***index_array ;
	index_array     = (uint32_t ***)malloc(sizeof(uint32_t *));
    for(int i = 0 ; i < Days  ; i++)
  400cdb:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  400cdf:	81 7d e8 97 1c 00 00 	cmpl   $0x1c97,-0x18(%rbp)
  400ce6:	7e d0                	jle    400cb8 <qsvr_init+0x89>
          index_array[i]  = (uint32_t **)malloc(malloc_sec_hash_len);
	
	init_val->hash 			= hash_key 		;
  400ce8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  400cec:	48 8d 95 a0 f7 ff ff 	lea    -0x860(%rbp),%rdx
  400cf3:	48 89 50 08          	mov    %rdx,0x8(%rax)
	init_val->origin_array 	= origin_array  ;
  400cf7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  400cfb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  400cff:	48 89 50 10          	mov    %rdx,0x10(%rax)
	init_val->index_array 	= index_array   ;
  400d03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  400d07:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  400d0b:	48 89 10             	mov    %rdx,(%rax)

	FILE *stream ;
  	char buf[128]={0} ,*tmp_array[Type_size] ;
  400d0e:	48 8d 95 20 f7 ff ff 	lea    -0x8e0(%rbp),%rdx
  400d15:	b8 00 00 00 00       	mov    $0x0,%eax
  400d1a:	b9 10 00 00 00       	mov    $0x10,%ecx
  400d1f:	48 89 d7             	mov    %rdx,%rdi
  400d22:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	stream = fopen(path,"r+");
  400d25:	48 8b 85 d8 f6 ff ff 	mov    -0x928(%rbp),%rax
  400d2c:	be 60 13 40 00       	mov    $0x401360,%esi
  400d31:	48 89 c7             	mov    %rax,%rdi
  400d34:	e8 37 fa ff ff       	callq  400770 <fopen@plt>
  400d39:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
 	if (stream == NULL)
  400d3d:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  400d42:	75 2a                	jne    400d6e <qsvr_init+0x13f>
  	{
      printf("can't open input_data.txt \n,%s",strerror(errno));
  400d44:	e8 77 f9 ff ff       	callq  4006c0 <__errno_location@plt>
  400d49:	8b 00                	mov    (%rax),%eax
  400d4b:	89 c7                	mov    %eax,%edi
  400d4d:	e8 3e fa ff ff       	callq  400790 <strerror@plt>
  400d52:	48 89 c6             	mov    %rax,%rsi
  400d55:	bf 68 13 40 00       	mov    $0x401368,%edi
  400d5a:	b8 00 00 00 00       	mov    $0x0,%eax
  400d5f:	e8 9c f9 ff ff       	callq  400700 <printf@plt>
      return NULL ;
  400d64:	b8 00 00 00 00       	mov    $0x0,%eax
  400d69:	e9 81 02 00 00       	jmpq   400fef <qsvr_init+0x3c0>
  	}
	while(fgets(buf,128,stream))
  400d6e:	e9 4a 01 00 00       	jmpq   400ebd <qsvr_init+0x28e>
  	{
      char *cur = buf ,*front =buf ;
  400d73:	48 8d 85 20 f7 ff ff 	lea    -0x8e0(%rbp),%rax
  400d7a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  400d7e:	48 8d 85 20 f7 ff ff 	lea    -0x8e0(%rbp),%rax
  400d85:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      int outer = 0;
  400d89:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
      while(*cur != '\n' )
  400d90:	eb 42                	jmp    400dd4 <qsvr_init+0x1a5>
      {   
        int inner = 0 ; 
  400d92:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%rbp)
        if( ' ' == *cur )
  400d99:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d9d:	0f b6 00             	movzbl (%rax),%eax
  400da0:	3c 20                	cmp    $0x20,%al
  400da2:	75 2b                	jne    400dcf <qsvr_init+0x1a0>
        {
              *cur = '\0';
  400da4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400da8:	c6 00 00             	movb   $0x0,(%rax)
              tmp_array[outer] = front ;
  400dab:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  400dae:	48 98                	cltq   
  400db0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400db4:	48 89 94 c5 f0 f6 ff 	mov    %rdx,-0x910(%rbp,%rax,8)
  400dbb:	ff 
              cur++;
  400dbc:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
              front = cur ;
  400dc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400dc5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
              outer++;
  400dc9:	83 45 d4 01          	addl   $0x1,-0x2c(%rbp)
  400dcd:	eb 05                	jmp    400dd4 <qsvr_init+0x1a5>
          }
          else
              cur++;
  400dcf:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  	}
	while(fgets(buf,128,stream))
  	{
      char *cur = buf ,*front =buf ;
      int outer = 0;
      while(*cur != '\n' )
  400dd4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400dd8:	0f b6 00             	movzbl (%rax),%eax
  400ddb:	3c 0a                	cmp    $0xa,%al
  400ddd:	75 b3                	jne    400d92 <qsvr_init+0x163>
              outer++;
          }
          else
              cur++;
      }
      tmp_array[outer] = front;
  400ddf:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  400de2:	48 98                	cltq   
  400de4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400de8:	48 89 94 c5 f0 f6 ff 	mov    %rdx,-0x910(%rbp,%rax,8)
  400def:	ff 
      origin_array[index].date = atoi(tmp_array[0]);
  400df0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400df3:	48 98                	cltq   
  400df5:	48 69 d0 b8 00 00 00 	imul   $0xb8,%rax,%rdx
  400dfc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  400e00:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  400e04:	48 8b 85 f0 f6 ff ff 	mov    -0x910(%rbp),%rax
  400e0b:	48 89 c7             	mov    %rax,%rdi
  400e0e:	e8 6d f9 ff ff       	callq  400780 <atoi@plt>
  400e13:	89 03                	mov    %eax,(%rbx)
      sprintf(origin_array[index].item,"%s",tmp_array[1]);
  400e15:	48 8b 85 f8 f6 ff ff 	mov    -0x908(%rbp),%rax
  400e1c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400e1f:	48 63 d2             	movslq %edx,%rdx
  400e22:	48 69 ca b8 00 00 00 	imul   $0xb8,%rdx,%rcx
  400e29:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  400e2d:	48 01 ca             	add    %rcx,%rdx
  400e30:	48 83 c2 04          	add    $0x4,%rdx
  400e34:	48 89 c6             	mov    %rax,%rsi
  400e37:	48 89 d7             	mov    %rdx,%rdi
  400e3a:	e8 91 f8 ff ff       	callq  4006d0 <strcpy@plt>
      sprintf(origin_array[index].contract,"%s",tmp_array[2]);
  400e3f:	48 8b 85 00 f7 ff ff 	mov    -0x900(%rbp),%rax
  400e46:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400e49:	48 63 d2             	movslq %edx,%rdx
  400e4c:	48 69 ca b8 00 00 00 	imul   $0xb8,%rdx,%rcx
  400e53:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  400e57:	48 01 ca             	add    %rcx,%rdx
  400e5a:	48 83 c2 0c          	add    $0xc,%rdx
  400e5e:	48 89 c6             	mov    %rax,%rsi
  400e61:	48 89 d7             	mov    %rdx,%rdi
  400e64:	e8 67 f8 ff ff       	callq  4006d0 <strcpy@plt>
      origin_array[index].rank = atoi(tmp_array[3]);
  400e69:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e6c:	48 98                	cltq   
  400e6e:	48 69 d0 b8 00 00 00 	imul   $0xb8,%rax,%rdx
  400e75:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  400e79:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  400e7d:	48 8b 85 08 f7 ff ff 	mov    -0x8f8(%rbp),%rax
  400e84:	48 89 c7             	mov    %rax,%rdi
  400e87:	e8 f4 f8 ff ff       	callq  400780 <atoi@plt>
  400e8c:	89 43 14             	mov    %eax,0x14(%rbx)
      sprintf(origin_array[index].address,"%s",tmp_array[4]);
  400e8f:	48 8b 85 10 f7 ff ff 	mov    -0x8f0(%rbp),%rax
  400e96:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400e99:	48 63 d2             	movslq %edx,%rdx
  400e9c:	48 69 ca b8 00 00 00 	imul   $0xb8,%rdx,%rcx
  400ea3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  400ea7:	48 01 ca             	add    %rcx,%rdx
  400eaa:	48 83 c2 30          	add    $0x30,%rdx
  400eae:	48 89 c6             	mov    %rax,%rsi
  400eb1:	48 89 d7             	mov    %rdx,%rdi
  400eb4:	e8 17 f8 ff ff       	callq  4006d0 <strcpy@plt>
      index++;
  400eb9:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
 	if (stream == NULL)
  	{
      printf("can't open input_data.txt \n,%s",strerror(errno));
      return NULL ;
  	}
	while(fgets(buf,128,stream))
  400ebd:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  400ec1:	48 8d 85 20 f7 ff ff 	lea    -0x8e0(%rbp),%rax
  400ec8:	be 80 00 00 00       	mov    $0x80,%esi
  400ecd:	48 89 c7             	mov    %rax,%rdi
  400ed0:	e8 5b f8 ff ff       	callq  400730 <fgets@plt>
  400ed5:	48 85 c0             	test   %rax,%rax
  400ed8:	0f 85 95 fe ff ff    	jne    400d73 <qsvr_init+0x144>
      sprintf(origin_array[index].contract,"%s",tmp_array[2]);
      origin_array[index].rank = atoi(tmp_array[3]);
      sprintf(origin_array[index].address,"%s",tmp_array[4]);
      index++;
   	};
	fclose(stream);
  400ede:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  400ee2:	48 89 c7             	mov    %rax,%rdi
  400ee5:	e8 06 f8 ff ff       	callq  4006f0 <fclose@plt>
//map item to dictionary
	stream  = fopen("../uniq.txt","r+"); //reuse stream 
  400eea:	be 60 13 40 00       	mov    $0x401360,%esi
  400eef:	bf 87 13 40 00       	mov    $0x401387,%edi
  400ef4:	e8 77 f8 ff ff       	callq  400770 <fopen@plt>
  400ef9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    if (stream == NULL)
  400efd:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  400f02:	75 2a                	jne    400f2e <qsvr_init+0x2ff>
    {
         printf("can't open uniq.txt \n,%s",strerror(errno));
  400f04:	e8 b7 f7 ff ff       	callq  4006c0 <__errno_location@plt>
  400f09:	8b 00                	mov    (%rax),%eax
  400f0b:	89 c7                	mov    %eax,%edi
  400f0d:	e8 7e f8 ff ff       	callq  400790 <strerror@plt>
  400f12:	48 89 c6             	mov    %rax,%rsi
  400f15:	bf 93 13 40 00       	mov    $0x401393,%edi
  400f1a:	b8 00 00 00 00       	mov    $0x0,%eax
  400f1f:	e8 dc f7 ff ff       	callq  400700 <printf@plt>
         return NULL;
  400f24:	b8 00 00 00 00       	mov    $0x0,%eax
  400f29:	e9 c1 00 00 00       	jmpq   400fef <qsvr_init+0x3c0>
    }
	index = 0 ; //reuse  index 
  400f2e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    while(fgets(buf,128,stream)) //reuse buf
  400f35:	eb 6c                	jmp    400fa3 <qsvr_init+0x374>
    {
          uint32_t middle_key ;
          char tmp_buf[5];
          int i ;
          for(i = 0 ;buf[i] != '\n' ; i++)
  400f37:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
  400f3e:	eb 1d                	jmp    400f5d <qsvr_init+0x32e>
          tmp_buf[i] = buf[i];
  400f40:	8b 45 d0             	mov    -0x30(%rbp),%eax
  400f43:	48 98                	cltq   
  400f45:	0f b6 94 05 20 f7 ff 	movzbl -0x8e0(%rbp,%rax,1),%edx
  400f4c:	ff 
  400f4d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  400f50:	48 98                	cltq   
  400f52:	88 94 05 e0 f6 ff ff 	mov    %dl,-0x920(%rbp,%rax,1)
    while(fgets(buf,128,stream)) //reuse buf
    {
          uint32_t middle_key ;
          char tmp_buf[5];
          int i ;
          for(i = 0 ;buf[i] != '\n' ; i++)
  400f59:	83 45 d0 01          	addl   $0x1,-0x30(%rbp)
  400f5d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  400f60:	48 98                	cltq   
  400f62:	0f b6 84 05 20 f7 ff 	movzbl -0x8e0(%rbp,%rax,1),%eax
  400f69:	ff 
  400f6a:	3c 0a                	cmp    $0xa,%al
  400f6c:	75 d2                	jne    400f40 <qsvr_init+0x311>
          tmp_buf[i] = buf[i];
          tmp_buf[i] = '\0';
  400f6e:	8b 45 d0             	mov    -0x30(%rbp),%eax
  400f71:	48 98                	cltq   
  400f73:	c6 84 05 e0 f6 ff ff 	movb   $0x0,-0x920(%rbp,%rax,1)
  400f7a:	00 
  
          middle_key  = calculate_item_key(tmp_buf);
  400f7b:	48 8d 85 e0 f6 ff ff 	lea    -0x920(%rbp),%rax
  400f82:	48 89 c7             	mov    %rax,%rdi
  400f85:	e8 0c f9 ff ff       	callq  400896 <calculate_item_key>
  400f8a:	89 45 a0             	mov    %eax,-0x60(%rbp)
          hash_key[middle_key]= index+1 ;
  400f8d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400f90:	83 c0 01             	add    $0x1,%eax
  400f93:	89 c2                	mov    %eax,%edx
  400f95:	8b 45 a0             	mov    -0x60(%rbp),%eax
  400f98:	89 94 85 a0 f7 ff ff 	mov    %edx,-0x860(%rbp,%rax,4)
          index++;
  400f9f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
    {
         printf("can't open uniq.txt \n,%s",strerror(errno));
         return NULL;
    }
	index = 0 ; //reuse  index 
    while(fgets(buf,128,stream)) //reuse buf
  400fa3:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  400fa7:	48 8d 85 20 f7 ff ff 	lea    -0x8e0(%rbp),%rax
  400fae:	be 80 00 00 00       	mov    $0x80,%esi
  400fb3:	48 89 c7             	mov    %rax,%rdi
  400fb6:	e8 75 f7 ff ff       	callq  400730 <fgets@plt>
  400fbb:	48 85 c0             	test   %rax,%rax
  400fbe:	0f 85 73 ff ff ff    	jne    400f37 <qsvr_init+0x308>
  
          middle_key  = calculate_item_key(tmp_buf);
          hash_key[middle_key]= index+1 ;
          index++;
     }
     fclose(stream);
  400fc4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  400fc8:	48 89 c7             	mov    %rax,%rdi
  400fcb:	e8 20 f7 ff ff       	callq  4006f0 <fclose@plt>
     map_key(init_val , History_len);
  400fd0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  400fd4:	be fc 7c 06 00       	mov    $0x67cfc,%esi
  400fd9:	48 89 c7             	mov    %rax,%rdi
  400fdc:	e8 43 fb ff ff       	callq  400b24 <map_key>
     printf("map success \n");
  400fe1:	bf ac 13 40 00       	mov    $0x4013ac,%edi
  400fe6:	e8 f5 f6 ff ff       	callq  4006e0 <puts@plt>
return init_val ;
  400feb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  400fef:	48 81 c4 28 09 00 00 	add    $0x928,%rsp
  400ff6:	5b                   	pop    %rbx
  400ff7:	5d                   	pop    %rbp
  400ff8:	c3                   	retq   

0000000000400ff9 <qsvr_find>:

void
qsvr_find(struct quote_map* qm, u32_int date , char *item , u32_int rank , struct qsvr *ret_val )
{
  400ff9:	55                   	push   %rbp
  400ffa:	48 89 e5             	mov    %rsp,%rbp
  400ffd:	48 83 ec 40          	sub    $0x40,%rsp
  401001:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  401005:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  401008:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  40100c:	89 4d d0             	mov    %ecx,-0x30(%rbp)
  40100f:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	  uint32_t tmp_item = 0  ,year_key = 0 ,item_key = 0 , rank_key = 0 ; 
  401013:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40101a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401021:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  401028:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
      year_key = calculate_year_key(date);
  40102f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  401032:	89 c7                	mov    %eax,%edi
  401034:	e8 09 f9 ff ff       	callq  400942 <calculate_year_key>
  401039:	89 45 f8             	mov    %eax,-0x8(%rbp)
      tmp_item = calculate_item_key(item);
  40103c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  401040:	48 89 c7             	mov    %rax,%rdi
  401043:	e8 4e f8 ff ff       	callq  400896 <calculate_item_key>
  401048:	89 45 fc             	mov    %eax,-0x4(%rbp)
      item_key = qm->hash[tmp_item] + rank ;
  40104b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40104f:	48 8b 40 08          	mov    0x8(%rax),%rax
  401053:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401056:	48 c1 e2 02          	shl    $0x2,%rdx
  40105a:	48 01 d0             	add    %rdx,%rax
  40105d:	8b 10                	mov    (%rax),%edx
  40105f:	8b 45 d0             	mov    -0x30(%rbp),%eax
  401062:	01 d0                	add    %edx,%eax
  401064:	89 45 f4             	mov    %eax,-0xc(%rbp)
      
      struct qsvr * val ;
      val  =(struct qsvr *) qm->index_array[year_key][item_key];
  401067:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40106b:	48 8b 00             	mov    (%rax),%rax
  40106e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401071:	48 c1 e2 03          	shl    $0x3,%rdx
  401075:	48 01 d0             	add    %rdx,%rax
  401078:	48 8b 00             	mov    (%rax),%rax
  40107b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40107e:	48 c1 e2 03          	shl    $0x3,%rdx
  401082:	48 01 d0             	add    %rdx,%rax
  401085:	48 8b 00             	mov    (%rax),%rax
  401088:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
   //   printf("contract: %s , address : %s\n",val->contract,val->address);
      memcpy(ret_val,val,8);
  40108c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  401090:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401094:	ba 08 00 00 00       	mov    $0x8,%edx
  401099:	48 89 ce             	mov    %rcx,%rsi
  40109c:	48 89 c7             	mov    %rax,%rdi
  40109f:	e8 ac f6 ff ff       	callq  400750 <memcpy@plt>
      memcpy(ret_val,val,128);
  4010a4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  4010a8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  4010ac:	ba 80 00 00 00       	mov    $0x80,%edx
  4010b1:	48 89 ce             	mov    %rcx,%rsi
  4010b4:	48 89 c7             	mov    %rax,%rdi
  4010b7:	e8 94 f6 ff ff       	callq  400750 <memcpy@plt>
}
  4010bc:	c9                   	leaveq 
  4010bd:	c3                   	retq   

00000000004010be <qsvr_destroy>:

void
qsvr_destroy(struct quote_map* qm)
{
  4010be:	55                   	push   %rbp
  4010bf:	48 89 e5             	mov    %rsp,%rbp
  4010c2:	48 83 ec 10          	sub    $0x10,%rsp
  4010c6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	//free(qm->origin_array);
	//for(int i = 0 ; i <Days ;i++)
	//	free(qm->index_array[i]);
	free(qm->index_array[1]);	
  4010ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4010ce:	48 8b 00             	mov    (%rax),%rax
  4010d1:	48 83 c0 08          	add    $0x8,%rax
  4010d5:	48 8b 00             	mov    (%rax),%rax
  4010d8:	48 89 c7             	mov    %rax,%rdi
  4010db:	e8 d0 f5 ff ff       	callq  4006b0 <free@plt>
// release mem of qm
	printf("qsvr_destroy is clean \n");
  4010e0:	bf b9 13 40 00       	mov    $0x4013b9,%edi
  4010e5:	e8 f6 f5 ff ff       	callq  4006e0 <puts@plt>
}
  4010ea:	c9                   	leaveq 
  4010eb:	c3                   	retq   

00000000004010ec <main>:

int main()
{
  4010ec:	55                   	push   %rbp
  4010ed:	48 89 e5             	mov    %rsp,%rbp
  4010f0:	48 83 ec 30          	sub    $0x30,%rsp
	const char *path = "../input_data.txt";
  4010f4:	48 c7 45 f8 d0 13 40 	movq   $0x4013d0,-0x8(%rbp)
  4010fb:	00 
	struct quote_map *test_map ;
	struct qsvr *test_val ;
	test_val = (struct qsvr *)malloc(sizeof(struct qsvr));
  4010fc:	bf b8 00 00 00       	mov    $0xb8,%edi
  401101:	e8 5a f6 ff ff       	callq  400760 <malloc@plt>
  401106:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	memset(test_val,0,sizeof(struct qsvr));
  40110a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40110e:	ba b8 00 00 00       	mov    $0xb8,%edx
  401113:	be 00 00 00 00       	mov    $0x0,%esi
  401118:	48 89 c7             	mov    %rax,%rdi
  40111b:	e8 f0 f5 ff ff       	callq  400710 <memset@plt>

	printf("start ! \n");
  401120:	bf e2 13 40 00       	mov    $0x4013e2,%edi
  401125:	e8 b6 f5 ff ff       	callq  4006e0 <puts@plt>
	test_map =  qsvr_init(path);
  40112a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40112e:	48 89 c7             	mov    %rax,%rdi
  401131:	e8 f9 fa ff ff       	callq  400c2f <qsvr_init>
  401136:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
	uint32_t test_time = 20140825 , test_rank = 4;
  40113a:	c7 45 e4 19 53 33 01 	movl   $0x1335319,-0x1c(%rbp)
  401141:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%rbp)
    char *test_item ="shag";
  401148:	48 c7 45 d8 eb 13 40 	movq   $0x4013eb,-0x28(%rbp)
  40114f:	00 
	printf("test find \n");
  401150:	bf f0 13 40 00       	mov    $0x4013f0,%edi
  401155:	e8 86 f5 ff ff       	callq  4006e0 <puts@plt>
	qsvr_find(test_map,test_time,test_item,test_rank,test_val);
  40115a:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  40115e:	8b 4d e0             	mov    -0x20(%rbp),%ecx
  401161:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  401165:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  401168:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40116c:	49 89 f8             	mov    %rdi,%r8
  40116f:	48 89 c7             	mov    %rax,%rdi
  401172:	e8 82 fe ff ff       	callq  400ff9 <qsvr_find>
	if(test_val != NULL)
  401177:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  40117c:	74 35                	je     4011b3 <main+0xc7>
      {
          printf("contract: %s , address : %s\n",test_val->contract,test_val->address  );
  40117e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401182:	48 8d 50 30          	lea    0x30(%rax),%rdx
  401186:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40118a:	48 83 c0 0c          	add    $0xc,%rax
  40118e:	48 89 c6             	mov    %rax,%rsi
  401191:	bf fb 13 40 00       	mov    $0x4013fb,%edi
  401196:	b8 00 00 00 00       	mov    $0x0,%eax
  40119b:	e8 60 f5 ff ff       	callq  400700 <printf@plt>
      else
      {
          printf("can't find \n");
          return -1 ;
      }
	qsvr_destroy(test_map);	
  4011a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4011a4:	48 89 c7             	mov    %rax,%rdi
  4011a7:	e8 12 ff ff ff       	callq  4010be <qsvr_destroy>
		
return 0 ;
  4011ac:	b8 00 00 00 00       	mov    $0x0,%eax
  4011b1:	eb 0f                	jmp    4011c2 <main+0xd6>
      {
          printf("contract: %s , address : %s\n",test_val->contract,test_val->address  );
      }
      else
      {
          printf("can't find \n");
  4011b3:	bf 18 14 40 00       	mov    $0x401418,%edi
  4011b8:	e8 23 f5 ff ff       	callq  4006e0 <puts@plt>
          return -1 ;
  4011bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
	qsvr_destroy(test_map);	
		
return 0 ;
}
  4011c2:	c9                   	leaveq 
  4011c3:	c3                   	retq   
  4011c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4011cb:	00 00 00 
  4011ce:	66 90                	xchg   %ax,%ax

00000000004011d0 <__libc_csu_init>:
  4011d0:	41 57                	push   %r15
  4011d2:	41 89 ff             	mov    %edi,%r15d
  4011d5:	41 56                	push   %r14
  4011d7:	49 89 f6             	mov    %rsi,%r14
  4011da:	41 55                	push   %r13
  4011dc:	49 89 d5             	mov    %rdx,%r13
  4011df:	41 54                	push   %r12
  4011e1:	4c 8d 25 88 04 20 00 	lea    0x200488(%rip),%r12        # 601670 <__frame_dummy_init_array_entry>
  4011e8:	55                   	push   %rbp
  4011e9:	48 8d 2d 88 04 20 00 	lea    0x200488(%rip),%rbp        # 601678 <__init_array_end>
  4011f0:	53                   	push   %rbx
  4011f1:	4c 29 e5             	sub    %r12,%rbp
  4011f4:	31 db                	xor    %ebx,%ebx
  4011f6:	48 c1 fd 03          	sar    $0x3,%rbp
  4011fa:	48 83 ec 08          	sub    $0x8,%rsp
  4011fe:	e8 75 f4 ff ff       	callq  400678 <_init>
  401203:	48 85 ed             	test   %rbp,%rbp
  401206:	74 1e                	je     401226 <__libc_csu_init+0x56>
  401208:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40120f:	00 
  401210:	4c 89 ea             	mov    %r13,%rdx
  401213:	4c 89 f6             	mov    %r14,%rsi
  401216:	44 89 ff             	mov    %r15d,%edi
  401219:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  40121d:	48 83 c3 01          	add    $0x1,%rbx
  401221:	48 39 eb             	cmp    %rbp,%rbx
  401224:	75 ea                	jne    401210 <__libc_csu_init+0x40>
  401226:	48 83 c4 08          	add    $0x8,%rsp
  40122a:	5b                   	pop    %rbx
  40122b:	5d                   	pop    %rbp
  40122c:	41 5c                	pop    %r12
  40122e:	41 5d                	pop    %r13
  401230:	41 5e                	pop    %r14
  401232:	41 5f                	pop    %r15
  401234:	c3                   	retq   
  401235:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  40123c:	00 00 00 00 

0000000000401240 <__libc_csu_fini>:
  401240:	f3 c3                	repz retq 

Disassembly of section .fini:

0000000000401244 <_fini>:
  401244:	48 83 ec 08          	sub    $0x8,%rsp
  401248:	48 83 c4 08          	add    $0x8,%rsp
  40124c:	c3                   	retq   
